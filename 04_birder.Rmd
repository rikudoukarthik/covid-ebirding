---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Birder behaviour (focus level: checklists)

Changes in eBirder behaviour will be analysed using the focal data point, checklists. A number of metrics based on checklists will be calculated and analysed (**at the monthly scale**), such as:

1.  Number of submitted checklists
    1.  Total lists\
    2.  Shared lists (use no. of obs.)\
2.  Number of submitted checklists per observer
    1.  Total lists\
    2.  Shared lists (use no. of obs.)\
3.  Hotspot birding\
4.  Birding protocol\
5.  Birding distance
6.  Site fidelity per observer\
7.  Habitats surveyed\
8.  Spatial spread of birding activity. These spatial patterns will be explored at two scales too: nationwide and regional.
    1.  Spatial spread by absences\
    2.  Spatial spread by densities\
9.  List duration
10. List length\
11. Birding time per observer (monthly for prelim, later maybe daily)\
12. Temporal spread of birding activity
    1.  Temporal spread within day (time-of-day)\
    2.  Temporal spread within week (day-of-week)\
13. Media\
14. Number of new birders

When running the actual models, observer will be used as a random effect because all of these metrics would vary differently from observer to observer.

Post-presentation: regarding averaging national level patterns by state for some metrics, this means that means are manually calculated for states and the points plotted in the graph are only these single points per state (instead of all the raw data points).

GLMMs for birder behaviour run only for the following metrics:

-   Group birding per observer
-   Site fidelity per observer
-   Birding time per observer
-   Hotspot birding
-   Birding protocol
-   Birding distance
-   List duration
-   List length
-   Proportion of urban birding
-   Spatial coverage
-   Spatial spread (slightly different)
-   Temporal spread

These are usually driven by decision at the state level, so since the models are being run for the states individually, no need to consider district.

### Group birding (>2 observer) per observer

```{r d01_group_po, cache=TRUE, message=FALSE}

anal_name <- "d01_group_po"

##### Final analysis: national GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
# taking data from all states instead of just chosen 4
data0_a <- data0_MY_slice_S %>% 
  tidyr::expand(nesting(MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA)

data_a <- data0_MY_slice_S %>% 
  group_by(M.YEAR, MONTH, OBSERVER.ID, SAMPLING.EVENT.IDENTIFIER) %>% 
  dplyr::summarise(GROUP.BIRDING = if_else(NUMBER.OBSERVERS > 2, 1, 0)) %>%
  ungroup()

tictoc::tic(glue("GLMM for India"))
model_a <- glmer(GROUP.BIRDING ~ M.YEAR + M.YEAR:MONTH + (1|OBSERVER.ID),
                 data = data_a, family = binomial(link = "cloglog"),
                 nAGQ = 0, control = glmerControl(optimizer = "bobyqa")) 
tictoc::toc()
# 220 sec


tictoc::tic(glue("Bootstrapped predictions for India"))
prediction <- split_par_boot(model = model_a, 
                             new_data = data0_a, 
                             new_data_string = "data0_a", 
                             mode = "extra")
tictoc::toc() # 205 min


for (i in 1:length(data0_a$MONTH)) {
  
  data0_a$PRED.LINK[i] <- median(na.omit(prediction[,i]))
  data0_a$SE.LINK[i] <- sd(na.omit(prediction[,i]))

}

data0_a <- data0_a %>% 
  mutate(PRED = clogloglink(PRED.LINK, inverse = T),
         CI.L = clogloglink((PRED.LINK - SE.LINK), inverse = T)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)


##### Final analysis: statewise GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
data0_b <- data0_MY_slice_S %>% 
  filter(STATE %in% anal_states[1,]) %>% 
  tidyr::expand(nesting(STATE, MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA,
         STATE = factor(STATE, levels = anal_states[1,])) %>% 
  arrange(STATE)


for (i in 1:4) { # for each state
  
  data0_b2 <- data0_b %>% filter(STATE == anal_states[, i])
  
  data_b <- data0_MY_slice_S %>% 
    filter(STATE == anal_states[, i]) %>% 
    group_by(M.YEAR, MONTH, OBSERVER.ID, SAMPLING.EVENT.IDENTIFIER) %>% 
    dplyr::summarise(GROUP.BIRDING = if_else(NUMBER.OBSERVERS > 2, 1, 0)) %>%
    ungroup() 
  
  tictoc::tic(glue("GLMM for {anal_states[, i]}"))
  model_b <- glmer(GROUP.BIRDING ~ M.YEAR + M.YEAR:MONTH + (1|OBSERVER.ID),
                   data = data_b, family = binomial(link = "cloglog"),
                   nAGQ = 0, control = glmerControl(optimizer = "bobyqa")) 
  tictoc::toc()
  
  
  tictoc::tic(glue("Bootstrapped predictions for {anal_states[, i]}"))
  prediction <- boot_conf_GLMM(model_b,
                               new_data = data0_b2,
                               new_data_string = "data0_b2",
                               nsim = 1000)
  tictoc::toc()
  
  for (j in 1:length(data0_b2$MONTH)) {
    
    data0_b2$PRED.LINK[j] <- median(na.omit(prediction[,j]))
    data0_b2$SE.LINK[j] <- sd(na.omit(prediction[,j]))
    
  }
  
  data0_b <- data0_b %>% 
    left_join(data0_b2, by = c("STATE", "MONTH", "M.YEAR")) %>% 
    transmute(MONTH = MONTH,
              M.YEAR = M.YEAR,
              STATE = STATE,
              PRED.LINK = ifelse(!is.na(PRED.LINK.y), PRED.LINK.y, PRED.LINK.x),
              SE.LINK = ifelse(!is.na(SE.LINK.y), SE.LINK.y, SE.LINK.x))
  
} 

data0_b <- data0_b %>% 
  mutate(PRED = clogloglink(PRED.LINK, inverse = T),
         CI.L = clogloglink((PRED.LINK - SE.LINK), inverse = T)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)


##### Saving analysis objects ####

save(data0_a, data_a, model_a, data0_b, data_b, model_b, 
     file = glue("outputs/{anal_name}.RData"))

##### Graphs ####

plot_a <- ggplot(data0_a, 
       aes(MONTH, PRED, colour = M.YEAR)) +
  labs(title = "National-level models",
       x = "Month", y = "Predicted group birding proportion") +
  geom_point(size = 2, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                size = 1, width = 0.3, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Migratory\nyear")

ggsave(filename = glue("03_wrap_figs/{anal_name}_a.png"), plot = plot_a,
       dpi = 300, width = 11, height = 6, units = "in")

plot_b <- ggplot(data0_b, 
       aes(MONTH, PRED, colour = M.YEAR)) +
  facet_wrap(~ STATE, ncol = 2, scales = "free_y") +
  labs(title = "State-level models",
       x = "Month", y = "Predicted group birding proportion") +
  geom_point(size = 3, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                size = 1.5, width = 0.4, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Migratory\nyear")

ggsave(filename = glue("03_wrap_figs/{anal_name}_b.png"), plot = plot_b,
       dpi = 300, width = 22, height = 13, units = "in")

```

### Site fidelity per observer

```{r d02_fidelity_po, cache=TRUE, message=FALSE}

anal_name <- "d02_fidelity_po"

##### Final analysis: national GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
# taking data from all states instead of just chosen 4
data0_a <- data0_MY_slice_S %>% 
  tidyr::expand(nesting(MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA)

data_a <- data0_MY_slice_S %>% 
  group_by(M.YEAR, MONTH, OBSERVER.ID) %>% 
  dplyr::summarise(NO.SITES = n_distinct(CELL.ID)) %>% 
  ungroup() 
# not filling zeroes for M.YEAR-MONTH combos where observer had no list, because
# our aim is to see, from the people who were birding, how many sites did a birder 
# visit on average?
# number of sites is the focus here, not the individual observer (anyway a random effect)


tictoc::tic(glue("GLMM for India"))
model_a <- glmer(NO.SITES ~ M.YEAR + M.YEAR:MONTH + (1|OBSERVER.ID),
                 data = data_a, family = poisson,
                 nAGQ = 0, control = glmerControl(optimizer = "bobyqa")) 
tictoc::toc() # 15 sec


tictoc::tic(glue("Bootstrapped predictions for India"))
prediction <- split_par_boot(model = model_a, 
                             new_data = data0_a, 
                             new_data_string = "data0_a", 
                             mode = "normal")
tictoc::toc() # 791 sec (13)

for (i in 1:length(data0_a$MONTH)) {
  
  data0_a$PRED.LINK[i] <- median(na.omit(prediction[,i]))
  data0_a$SE.LINK[i] <- sd(na.omit(prediction[,i]))

}

data0_a <- data0_a %>% 
  mutate(PRED = exp(PRED.LINK),
         CI.L = exp(PRED.LINK - SE.LINK)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)

##### Final analysis: statewise GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
data0_b <- data0_MY_slice_S %>% 
  filter(STATE %in% anal_states[1,]) %>% 
  tidyr::expand(nesting(STATE, MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA,
         STATE = factor(STATE, levels = anal_states[1,])) %>% 
  arrange(STATE)


for (i in 1:4) { # for each state

  data0_b2 <- data0_b %>% filter(STATE == anal_states[, i])
  
  data_b <- data0_MY_slice_S %>% 
    left_join(obs_mainstates, by = "OBSERVER.ID") %>% 
    filter(MAIN.STATE == anal_states[, i]) %>% 
    group_by(M.YEAR, MONTH, OBSERVER.ID) %>% 
    dplyr::summarise(NO.SITES = n_distinct(CELL.ID)) %>% 
    ungroup() 
  # not filling zeroes for M.YEAR-MONTH combos where observer had no list, because
  # our aim is to see, from the people who were birding, how many sites did a birder 
  # visit on average?
  # number of sites is the focus here, not the individual observer (anyway a random effect)
  
  
  tictoc::tic(glue("GLMM for {anal_states[, i]}"))
  model_b <- glmer(NO.SITES ~ M.YEAR + M.YEAR:MONTH + (1|OBSERVER.ID),
                   data = data_b, family = poisson,
                   nAGQ = 0, control = glmerControl(optimizer = "bobyqa")) 
  tictoc::toc()
  
  
  tictoc::tic(glue("Bootstrapped predictions for {anal_states[, i]}"))
  prediction <- boot_conf_GLMM(model_b,
                               new_data = data0_b2,
                               new_data_string = "data0_b2",
                               nsim = 1000)
  tictoc::toc()
  
  for (j in 1:length(data0_b2$MONTH)) {
    
    data0_b2$PRED.LINK[j] <- median(na.omit(prediction[,j]))
    data0_b2$SE.LINK[j] <- sd(na.omit(prediction[,j]))
    
  }
  
  data0_b <- data0_b %>% 
    left_join(data0_b2, by = c("STATE", "MONTH", "M.YEAR")) %>% 
    transmute(MONTH = MONTH,
              M.YEAR = M.YEAR,
              STATE = STATE,
              PRED.LINK = ifelse(!is.na(PRED.LINK.y), PRED.LINK.y, PRED.LINK.x),
              SE.LINK = ifelse(!is.na(SE.LINK.y), SE.LINK.y, SE.LINK.x))
  
} 

data0_b <- data0_b %>% 
  mutate(PRED = exp(PRED.LINK),
         CI.L = exp(PRED.LINK - SE.LINK)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)

##### Saving analysis objects ####

save(data0_a, data_a, model_a, data0_b, data_b, model_b, 
     file = glue("outputs/{anal_name}.RData"))

##### Graphs ####

plot_a <- ggplot(data0_a, 
       aes(MONTH, PRED, colour = M.YEAR)) +
  labs(title = "National-level models",
       x = "Month", y = "Predicted no. of sites visited") +
  geom_point(size = 2, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                size = 1, width = 0.3, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Migratory\nyear")

ggsave(filename = glue("03_wrap_figs/{anal_name}_a.png"), plot = plot_a,
       dpi = 300, width = 11, height = 6, units = "in")

plot_b <- ggplot(data0_b, 
       aes(MONTH, PRED, colour = M.YEAR)) +
  facet_wrap(~ STATE, ncol = 2, scales = "free_y") +
  labs(title = "State-level models",
       x = "Month", y = "Predicted no. of sites visited") +
  geom_point(size = 3, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                size = 1.5, width = 0.4, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Migratory\nyear")

ggsave(filename = glue("03_wrap_figs/{anal_name}_b.png"), plot = plot_b,
       dpi = 300, width = 22, height = 13, units = "in")


```

-   At the national level, site fidelity was generally higher during the pandemic than before but mostly only around lockdown/second wave. In other months patterns closely followed pre-pandemic ones.

### Birding time per observer

```{r d03_time_po, cache=TRUE, message=FALSE}

anal_name <- "d03_time_po"

##### Final analysis: national GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
# taking data from all states instead of just chosen 4
data0_a <- data0_MY_slice_S %>% 
  tidyr::expand(nesting(MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA)

data_a <- data0_MY_slice_S %>% 
  group_by(M.YEAR, MONTH, OBSERVER.ID) %>% 
  dplyr::summarise(BIRDING.TIME = sum(DURATION.MINUTES)) %>% 
  ungroup() 
# not filling zeroes for M.YEAR-MONTH combos where observer had no list, because
# our aim is to see, from the people who were birding, how much time was spent?



tictoc::tic(glue("GLMM for India"))
model_a <- glmer(BIRDING.TIME ~ M.YEAR + M.YEAR:MONTH + (1|OBSERVER.ID),
                 data = data_a, family = poisson,
                 nAGQ = 0, control = glmerControl(optimizer = "bobyqa")) 
tictoc::toc() # 10 sec


tictoc::tic(glue("Bootstrapped predictions for India"))
prediction <- split_par_boot(model = model_a, 
                             new_data = data0_a, 
                             new_data_string = "data0_a", 
                             mode = "normal")
tictoc::toc() # 814 sec (13 min)

for (i in 1:length(data0_a$MONTH)) {
  
  data0_a$PRED.LINK[i] <- median(na.omit(prediction[,i]))
  data0_a$SE.LINK[i] <- sd(na.omit(prediction[,i]))

}

data0_a <- data0_a %>% 
  mutate(PRED = exp(PRED.LINK),
         CI.L = exp(PRED.LINK - SE.LINK)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)

##### Final analysis: statewise GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
data0_b <- data0_MY_slice_S %>% 
  filter(STATE %in% anal_states[1,]) %>% 
  tidyr::expand(nesting(STATE, MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA,
         STATE = factor(STATE, levels = anal_states[1,])) %>% 
  arrange(STATE)


for (i in 1:4) { # for each state

  data0_b2 <- data0_b %>% filter(STATE == anal_states[, i])
  
  data_b <- data0_MY_slice_S %>% 
    left_join(obs_mainstates, by = "OBSERVER.ID") %>% 
    filter(MAIN.STATE == anal_states[, i]) %>% 
    group_by(M.YEAR, MONTH, OBSERVER.ID) %>% 
    dplyr::summarise(BIRDING.TIME = sum(DURATION.MINUTES)) %>% 
    ungroup()
  # not filling zeroes for M.YEAR-MONTH combos where observer had no list, because
  # our aim is to see, from the people who were birding, how much time was spent?
  
  
  tictoc::tic(glue("GLMM for {anal_states[, i]}"))
  model_b <- glmer(BIRDING.TIME ~ M.YEAR + M.YEAR:MONTH + (1|OBSERVER.ID),
                   data = data_b, family = poisson,
                   nAGQ = 0, control = glmerControl(optimizer = "bobyqa")) 
  tictoc::toc()
  
  
  tictoc::tic(glue("Bootstrapped predictions for {anal_states[, i]}"))
  prediction <- boot_conf_GLMM(model_b,
                               new_data = data0_b2,
                               new_data_string = "data0_b2",
                               nsim = 1000)
  tictoc::toc()
  
  for (j in 1:length(data0_b2$MONTH)) {
    
    data0_b2$PRED.LINK[j] <- median(na.omit(prediction[,j]))
    data0_b2$SE.LINK[j] <- sd(na.omit(prediction[,j]))
    
  }
  
  data0_b <- data0_b %>% 
    left_join(data0_b2, by = c("STATE", "MONTH", "M.YEAR")) %>% 
    transmute(MONTH = MONTH,
              M.YEAR = M.YEAR,
              STATE = STATE,
              PRED.LINK = ifelse(!is.na(PRED.LINK.y), PRED.LINK.y, PRED.LINK.x),
              SE.LINK = ifelse(!is.na(SE.LINK.y), SE.LINK.y, SE.LINK.x))
  
} 

data0_b <- data0_b %>% 
  mutate(PRED = exp(PRED.LINK),
         CI.L = exp(PRED.LINK - SE.LINK)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)

##### Saving analysis objects ####

save(data0_a, data_a, model_a, data0_b, data_b, model_b, 
     file = glue("outputs/{anal_name}.RData"))

##### Graphs ####

plot_a <- ggplot(data0_a, 
       aes(MONTH, PRED, colour = M.YEAR)) +
  labs(title = "National-level models",
       x = "Month", y = "Predicted birding time per observer") +
  geom_point(size = 2, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                size = 1, width = 0.3, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Migratory\nyear")

ggsave(filename = glue("03_wrap_figs/{anal_name}_a.png"), plot = plot_a,
       dpi = 300, width = 11, height = 6, units = "in")

plot_b <- ggplot(data0_b, 
       aes(MONTH, PRED, colour = M.YEAR)) +
  facet_wrap(~ STATE, ncol = 2, scales = "free_y") +
  labs(title = "State-level models",
       x = "Month", y = "Predicted birding time per observer") +
  geom_point(size = 3, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                size = 1.5, width = 0.4, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Migratory\nyear")

ggsave(filename = glue("03_wrap_figs/{anal_name}_b.png"), plot = plot_b,
       dpi = 300, width = 22, height = 13, units = "in")


```

-   At the national level, birding times were and are lowest during monsoon. There was no noticeable negative impact of the pandemic on monthly birding times, except in March 2020 when the pandemic was a novelty. In fact, in the monsoon months of July and August, birding times even increased slightly during the pandemic.\
-   The only other major pattern visible at the state level is in Karnataka, where birding times have increased in the months of August--October.
-   Karnataka and Assam showed a lowered birding duration around the peak months, while Kerala and Maharashtra showed no difference.

### Hotspot birding

Not "per observer", as this metric from data POV.

```{r d04_hotspot, cache=TRUE, message=FALSE}

anal_name <- "d04_hotspot"

##### Final analysis: national GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
# taking data from all states instead of just chosen 4
data0_a <- data0_MY_slice_G %>% 
  tidyr::expand(nesting(MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA)

data_a <- data0_MY_slice_G %>% 
  group_by(M.YEAR, MONTH, CELL.ID, SAMPLING.EVENT.IDENTIFIER) %>% 
  dplyr::summarise(HOTSPOT = if_else(LOCALITY.TYPE == "H", 1, 0)) %>%
  ungroup()

tictoc::tic(glue("GLMM for India"))
model_a <- glmer(HOTSPOT ~ M.YEAR + M.YEAR:MONTH + (1|CELL.ID),
                 data = data_a, family = binomial(link = "cloglog"),
                 nAGQ = 0, control = glmerControl(optimizer = "bobyqa")) 
tictoc::toc()
# 150 sec


tictoc::tic(glue("Bootstrapped predictions for India"))
prediction <- split_par_boot(model = model_a, 
                             new_data = data0_a, 
                             new_data_string = "data0_a", 
                             mode = "extra")
tictoc::toc() # 7520 sec (2h5m)


for (i in 1:length(data0_a$MONTH)) {
  
  data0_a$PRED.LINK[i] <- median(na.omit(prediction[,i]))
  data0_a$SE.LINK[i] <- sd(na.omit(prediction[,i]))

}

data0_a <- data0_a %>% 
  mutate(PRED = clogloglink(PRED.LINK, inverse = T),
         CI.L = clogloglink((PRED.LINK - SE.LINK), inverse = T)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)

##### Final analysis: statewise GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
data0_b <- data0_MY_slice_G %>% 
  filter(STATE %in% anal_states[1,]) %>% 
  tidyr::expand(nesting(STATE, MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA,
         STATE = factor(STATE, levels = anal_states[1,])) %>% 
  arrange(STATE)


for (i in 1:4) { # for each state
  
  data0_b2 <- data0_b %>% filter(STATE == anal_states[, i])
    
  data_b <- data0_MY_slice_G %>% 
    filter(STATE == anal_states[, i]) %>% 
    group_by(M.YEAR, MONTH, CELL.ID, SAMPLING.EVENT.IDENTIFIER) %>% 
    dplyr::summarise(HOTSPOT = if_else(LOCALITY.TYPE == "H", 1, 0)) %>%
    ungroup() 
  
  tictoc::tic(glue("GLMM for {anal_states[, i]}"))
  model_b <- glmer(HOTSPOT ~ M.YEAR + M.YEAR:MONTH + (1|CELL.ID),
                   data = data_b, family = binomial(link = "cloglog"),
                   nAGQ = 0, control = glmerControl(optimizer = "bobyqa")) 
  tictoc::toc() #


  tictoc::tic(glue("Bootstrapped predictions for {anal_states[, i]}"))
  prediction <- boot_conf_GLMM(model_b,
                               new_data = data0_b2,
                               new_data_string = "data0_b2",
                               nsim = 1000)
  tictoc::toc() #
  
  for (j in 1:length(data0_b2$MONTH)) {
    
    data0_b2$PRED.LINK[j] <- median(na.omit(prediction[,j]))
    data0_b2$SE.LINK[j] <- sd(na.omit(prediction[,j]))
    
  }
  
  data0_b <- data0_b %>% 
    left_join(data0_b2, by = c("STATE", "MONTH", "M.YEAR")) %>% 
    transmute(MONTH = MONTH,
              M.YEAR = M.YEAR,
              STATE = STATE,
              PRED.LINK = ifelse(!is.na(PRED.LINK.y), PRED.LINK.y, PRED.LINK.x),
              SE.LINK = ifelse(!is.na(SE.LINK.y), SE.LINK.y, SE.LINK.x))
  
} 

data0_b <- data0_b %>% 
  mutate(PRED = clogloglink(PRED.LINK, inverse = T),
         CI.L = clogloglink((PRED.LINK - SE.LINK), inverse = T)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)


##### Saving analysis objects ####

save(data0_a, data_a, model_a, data0_b, data_b, model_b, 
     file = glue("outputs/{anal_name}.RData"))

##### Graphs ####

plot_a <- ggplot(data0_a, 
                 aes(MONTH, PRED, colour = M.YEAR)) +
  labs(title = "National-level models",
       x = "Month", y = "Predicted hotspot birding proportion") +
  geom_point(size = 2, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                size = 1, width = 0.3, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Migratory\nyear")

ggsave(filename = glue("03_wrap_figs/{anal_name}_a.png"), plot = plot_a,
       dpi = 300, width = 11, height = 6, units = "in")

plot_b <- ggplot(data0_b, 
                 aes(MONTH, PRED, colour = M.YEAR)) +
  facet_wrap(~ STATE, ncol = 2, scales = "free_y") +
  labs(title = "State-level models",
       x = "Month", y = "Predicted hotspot birding proportion") +
  geom_point(size = 3, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                size = 1.5, width = 0.4, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Migratory\nyear")

ggsave(filename = glue("03_wrap_figs/{anal_name}_b.png"), plot = plot_b,
       dpi = 300, width = 22, height = 13, units = "in")

```

-   The national level saw lower hotspot birding during the lockdown/second wave months, with some spillover into the months of June and July.\
-   In Karnataka, this impact surprisingly lasted through all of 2020 but returned almost exactly to pre-COVID levels in 2021. The same to an extent in Kerala, though the difference was much less.
-   Maharashtra recovered after the peak period, while there was no effect on Assam.

### Birding protocol

Not "per observer", as this metric from data POV.

```{r d05_protocol, cache=TRUE, message=FALSE}

anal_name <- "d05_protocol"

##### Final analysis: national GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
# taking data from all states instead of just chosen 4
data0_a <- data0_MY_slice_G %>% 
  tidyr::expand(nesting(MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA)

data_a <- data0_MY_slice_G %>% 
  group_by(M.YEAR, MONTH, CELL.ID, SAMPLING.EVENT.IDENTIFIER) %>% 
  dplyr::summarise(TRAVELLING = if_else((PROTOCOL.TYPE == "Traveling" & 
                                           EFFORT.DISTANCE.KM > 0.3), 1, 0)) %>%
  ungroup()

tictoc::tic(glue("GLMM for India"))
model_a <- glmer(TRAVELLING ~ M.YEAR + M.YEAR:MONTH + (1|CELL.ID),
                 data = data_a, family = binomial(link = "cloglog"),
                 nAGQ = 0, control = glmerControl(optimizer = "bobyqa")) 
tictoc::toc() # 110 sec


tictoc::tic(glue("Bootstrapped predictions for India"))
prediction <- split_par_boot(model = model_a, 
                             new_data = data0_a, 
                             new_data_string = "data0_a", 
                             mode = "extra")
tictoc::toc() # 6245 sec (104 min)


for (i in 1:length(data0_a$MONTH)) {
  
  data0_a$PRED.LINK[i] <- median(na.omit(prediction[,i]))
  data0_a$SE.LINK[i] <- sd(na.omit(prediction[,i]))

}

data0_a <- data0_a %>% 
  mutate(PRED = clogloglink(PRED.LINK, inverse = T),
         CI.L = clogloglink((PRED.LINK - SE.LINK), inverse = T)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)

##### Final analysis: statewise GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
data0_b <- data0_MY_slice_G %>% 
  filter(STATE %in% anal_states[1,]) %>% 
  tidyr::expand(nesting(STATE, MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA,
         STATE = factor(STATE, levels = anal_states[1,])) %>% 
  arrange(STATE)


for (i in 1:4) { # for each state
  
  data0_b2 <- data0_b %>% filter(STATE == anal_states[, i])
    
  data_b <- data0_MY_slice_G %>% 
    filter(STATE == anal_states[, i]) %>% 
    group_by(M.YEAR, MONTH, CELL.ID, SAMPLING.EVENT.IDENTIFIER) %>% 
    dplyr::summarise(TRAVELLING = if_else((PROTOCOL.TYPE == "Traveling" & 
                                             EFFORT.DISTANCE.KM > 0.3), 1, 0)) %>%
    ungroup()
  
  tictoc::tic(glue("GLMM for {anal_states[, i]}"))
  model_b <- glmer(TRAVELLING ~ M.YEAR + M.YEAR:MONTH + (1|CELL.ID),
                   data = data_b, family = binomial(link = "cloglog"),
                   nAGQ = 0, control = glmerControl(optimizer = "bobyqa")) 
  tictoc::toc() #


  tictoc::tic(glue("Bootstrapped predictions for {anal_states[, i]}"))
  prediction <- boot_conf_GLMM(model_b,
                               new_data = data0_b2,
                               new_data_string = "data0_b2",
                               nsim = 1000)
  tictoc::toc() #


  
  for (j in 1:length(data0_b2$MONTH)) {
    
    data0_b2$PRED.LINK[j] <- median(na.omit(prediction[,j]))
    data0_b2$SE.LINK[j] <- sd(na.omit(prediction[,j]))
    
  }
  
  data0_b <- data0_b %>% 
    left_join(data0_b2, by = c("STATE", "MONTH", "M.YEAR")) %>% 
    transmute(MONTH = MONTH,
              M.YEAR = M.YEAR,
              STATE = STATE,
              PRED.LINK = ifelse(!is.na(PRED.LINK.y), PRED.LINK.y, PRED.LINK.x),
              SE.LINK = ifelse(!is.na(SE.LINK.y), SE.LINK.y, SE.LINK.x))
  
} 

data0_b <- data0_b %>% 
  mutate(PRED = clogloglink(PRED.LINK, inverse = T),
         CI.L = clogloglink((PRED.LINK - SE.LINK), inverse = T)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)

##### Saving analysis objects ####

save(data0_a, data_a, model_a, data0_b, data_b, model_b, 
     file = glue("outputs/{anal_name}.RData"))

##### Graphs ####

plot_a <- ggplot(data0_a, 
                 aes(MONTH, PRED, colour = M.YEAR)) +
  labs(title = "National-level models",
       x = "Month", y = "Predicted travelling birding proportion") +
  geom_point(size = 2, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                size = 1, width = 0.3, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Migratory\nyear")

ggsave(filename = glue("03_wrap_figs/{anal_name}_a.png"), plot = plot_a,
       dpi = 300, width = 11, height = 6, units = "in")

plot_b <- ggplot(data0_b, 
                 aes(MONTH, PRED, colour = M.YEAR)) +
  facet_wrap(~ STATE, ncol = 2, scales = "free_y") +
  labs(title = "State-level models",
       x = "Month", y = "Predicted travelling birding proportion") +
  geom_point(size = 3, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                size = 1.5, width = 0.4, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Migratory\nyear")

ggsave(filename = glue("03_wrap_figs/{anal_name}_b.png"), plot = plot_b,
       dpi = 300, width = 22, height = 13, units = "in")


```

-   At the national level, mobility of birders, in terms of proportion of travelling lists submitted, decreased sharply during April--May as expected, and had some spillover into June and July, but matched pre-COVID levels well in the other months of the year.

### Birding distance

Not "per observer", as this metric from data POV. Only considers travelling lists.

```{r d06_distance, cache=TRUE, message=FALSE}

anal_name <- "d06_distance"

##### Final analysis: national GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
# taking data from all states instead of just chosen 4
data0_a <- data0_MY_slice_G %>% 
  tidyr::expand(nesting(MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA)

data_a <- data0_MY_slice_G %>% 
  filter(PROTOCOL.TYPE == "Traveling", !is.na(EFFORT.DISTANCE.KM), EFFORT.DISTANCE.KM > 0.3) %>% 
  group_by(M.YEAR, MONTH, CELL.ID, SAMPLING.EVENT.IDENTIFIER) %>% 
  dplyr::summarise(DISTANCE = log(EFFORT.DISTANCE.KM)) %>% 
  # because no other distribution family fits 
  ungroup() 


tictoc::tic(glue("LMM for India"))
model_a <- lmer(DISTANCE ~ M.YEAR + M.YEAR:MONTH + (1|CELL.ID),
                 data = data_a, 
                 control = lmerControl(optimizer = "bobyqa")) 
tictoc::toc() # 

tictoc::tic(glue("Bootstrapped predictions for India"))
prediction <- split_par_boot(model = model_a, 
                             new_data = data0_a, 
                             new_data_string = "data0_a", 
                             mode = "extra")
tictoc::toc() # 


for (i in 1:length(data0_a$MONTH)) {
  
  data0_a$PRED.LINK[i] <- median(na.omit(prediction[,i]))
  data0_a$SE.LINK[i] <- sd(na.omit(prediction[,i]))

}

data0_a <- data0_a %>% 
  # this step doesn't change even though we log-transform prior to fitting the model
  # since the output of prediction is on log scale either way. 
  mutate(PRED = exp(PRED.LINK),
         CI.L = exp(PRED.LINK - SE.LINK)) %>%
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)

##### Final analysis: statewise GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
data0_b <- data0_MY_slice_G %>% 
  filter(STATE %in% anal_states[1,]) %>% 
  tidyr::expand(nesting(STATE, MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA,
         STATE = factor(STATE, levels = anal_states[1,])) %>% 
  arrange(STATE)


for (i in 1:4) { # for each state
  
  data0_b2 <- data0_b %>% filter(STATE == anal_states[, i])
    
  data_b <- data0_MY_slice_G %>% 
    filter(STATE == anal_states[, i]) %>% 
    filter(PROTOCOL.TYPE == "Traveling", !is.na(EFFORT.DISTANCE.KM), EFFORT.DISTANCE.KM > 0.3) %>% 
    group_by(M.YEAR, MONTH, CELL.ID, SAMPLING.EVENT.IDENTIFIER) %>% 
    dplyr::summarise(DISTANCE = log(EFFORT.DISTANCE.KM)) %>% 
    # because no other distribution family fits 
    ungroup() 
  
  tictoc::tic(glue("LMM for {anal_states[, i]}"))
  model_b <- lmer(DISTANCE ~ M.YEAR + M.YEAR:MONTH + (1|CELL.ID),
                   data = data_b, 
                   control = lmerControl(optimizer = "bobyqa")) 
  tictoc::toc() #

  
  tictoc::tic(glue("Bootstrapped predictions for {anal_states[, i]}"))
  prediction <- boot_conf_GLMM(model_b,
                               new_data = data0_b2,
                               new_data_string = "data0_b2",
                               nsim = 1000)
  tictoc::toc() #


  
  for (j in 1:length(data0_b2$MONTH)) {
    
    data0_b2$PRED.LINK[j] <- median(na.omit(prediction[,j]))
    data0_b2$SE.LINK[j] <- sd(na.omit(prediction[,j]))
    
  }
  
  data0_b <- data0_b %>% 
    left_join(data0_b2, by = c("STATE", "MONTH", "M.YEAR")) %>% 
    transmute(MONTH = MONTH,
              M.YEAR = M.YEAR,
              STATE = STATE,
              PRED.LINK = ifelse(!is.na(PRED.LINK.y), PRED.LINK.y, PRED.LINK.x),
              SE.LINK = ifelse(!is.na(SE.LINK.y), SE.LINK.y, SE.LINK.x))
  
} 

data0_b <- data0_b %>% 
  mutate(PRED = exp(PRED.LINK),
         CI.L = exp(PRED.LINK - SE.LINK)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)


##### Saving analysis objects ####

save(data0_a, data_a, model_a, data0_b, data_b, model_b, 
     file = glue("outputs/{anal_name}.RData"))

##### Graphs ####

plot_a <- ggplot(data0_a, 
                 aes(MONTH, PRED, colour = M.YEAR)) +
  labs(title = "National-level models",
       x = "Month", y = "Predicted birding distance") +
  geom_point(size = 2, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                size = 1, width = 0.3, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Migratory\nyear")

ggsave(filename = glue("03_wrap_figs/{anal_name}_a.png"), plot = plot_a,
       dpi = 300, width = 11, height = 6, units = "in")

plot_b <- ggplot(data0_b, 
                 aes(MONTH, PRED, colour = M.YEAR)) +
  facet_wrap(~ STATE, ncol = 2, scales = "free_y") +
  labs(title = "State-level models",
       x = "Month", y = "Predicted birding distance") +
  geom_point(size = 3, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                size = 1.5, width = 0.4, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Migratory\nyear")

ggsave(filename = glue("03_wrap_figs/{anal_name}_b.png"), plot = plot_b,
       dpi = 300, width = 22, height = 13, units = "in")


```

-   At the national level, checklist distances were highest during summer and winter before the pandemic. During the pandemic, distances remained fairly similar for the winter months of October--December, but were drastically lower during the summer months of April and May, which coincided with the lockdown/second wave.\
-   Overall, this metric was not affected as much as others. Karnataka and Kerala showed some brief declines, but overall patterns are rather irregular, so nothing major. Maharashtra has shown a consistent decline since the start of the pandemic till now.

### List duration

Not "per observer", as this metric from data POV.

```{r d07_duration, cache=TRUE, message=FALSE}

anal_name <- "d07_duration"

##### Final analysis: national GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
# taking data from all states instead of just chosen 4
data0_a <- data0_MY_slice_G %>% 
  tidyr::expand(nesting(MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA)

data_a <- data0_MY_slice_G %>% 
  filter(!is.na(DURATION.MINUTES)) %>% 
  group_by(M.YEAR, MONTH, CELL.ID, SAMPLING.EVENT.IDENTIFIER) %>% 
  dplyr::summarise(DURATION = DURATION.MINUTES) %>%
  ungroup()

tictoc::tic(glue("GLMM for India"))
model_a <- glmer(DURATION ~ M.YEAR + M.YEAR:MONTH + (1|CELL.ID),
                 data = data_a, family = poisson,
                 nAGQ = 0, control = glmerControl(optimizer = "bobyqa")) 
tictoc::toc() # 


tictoc::tic(glue("Bootstrapped predictions for India"))
prediction <- split_par_boot(model = model_a, 
                             new_data = data0_a, 
                             new_data_string = "data0_a", 
                             mode = "extra")
tictoc::toc() # 


for (i in 1:length(data0_a$MONTH)) {
  
  data0_a$PRED.LINK[i] <- median(na.omit(prediction[,i]))
  data0_a$SE.LINK[i] <- sd(na.omit(prediction[,i]))

}

data0_a <- data0_a %>% 
  mutate(PRED = exp(PRED.LINK),
         CI.L = exp(PRED.LINK - SE.LINK)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)


##### Final analysis: statewise GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
data0_b <- data0_MY_slice_G %>% 
  filter(STATE %in% anal_states[1,]) %>% 
  tidyr::expand(nesting(STATE, MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA,
         STATE = factor(STATE, levels = anal_states[1,])) %>% 
  arrange(STATE)


for (i in 1:4) { # for each state

  data0_b2 <- data0_b %>% filter(STATE == anal_states[, i])
    
  data_b <- data0_MY_slice_G %>% 
    filter(!is.na(DURATION.MINUTES)) %>% 
    filter(STATE == anal_states[, i]) %>% 
    group_by(M.YEAR, MONTH, CELL.ID, SAMPLING.EVENT.IDENTIFIER) %>% 
    dplyr::summarise(DURATION = DURATION.MINUTES) %>%
    ungroup()
  
  tictoc::tic(glue("GLMM for {anal_states[, i]}"))
  model_b <- glmer(DURATION ~ M.YEAR + M.YEAR:MONTH + (1|CELL.ID),
                 data = data_a, family = poisson,
                 nAGQ = 0, control = glmerControl(optimizer = "bobyqa"))  
  tictoc::toc() #


  tictoc::tic(glue("Bootstrapped predictions for {anal_states[, i]}"))
  prediction <- boot_conf_GLMM(model_b,
                               new_data = data0_b2,
                               new_data_string = "data0_b2",
                               nsim = 1000)
  tictoc::toc() #


  
  for (j in 1:length(data0_b2$MONTH)) {
    
    data0_b2$PRED.LINK[j] <- median(na.omit(prediction[,j]))
    data0_b2$SE.LINK[j] <- sd(na.omit(prediction[,j]))
    
  }
  
  data0_b <- data0_b %>% 
    left_join(data0_b2, by = c("STATE", "MONTH", "M.YEAR")) %>% 
    transmute(MONTH = MONTH,
              M.YEAR = M.YEAR,
              STATE = STATE,
              PRED.LINK = ifelse(!is.na(PRED.LINK.y), PRED.LINK.y, PRED.LINK.x),
              SE.LINK = ifelse(!is.na(SE.LINK.y), SE.LINK.y, SE.LINK.x))
  
} 

data0_b <- data0_b %>% 
  mutate(PRED = exp(PRED.LINK),
         CI.L = exp(PRED.LINK - SE.LINK)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
data0 <- data0_MY_slice_G %>% 
  filter(STATE %in% anal_states[1,]) %>% 
  tidyr::expand(nesting(STATE, MONTH, M.YEAR)) %>% 
  mutate(PRED = NA,
         STATE = factor(STATE, levels = anal_states[1,])) %>% 
  arrange(STATE)

count <- 0
for (i in 1:4) { # for each state
  
  data_a <- data0_MY_slice_G %>% 
    filter(STATE == anal_states[, i]) %>% 
    # because no other family fits
    mutate(DURATION = log(DURATION.MINUTES))
  
  tictoc::tic(glue::glue("LMM for {anal_states[, i]}"))
  model_a <- lmer(DURATION ~ M.YEAR + M.YEAR:MONTH + (1|CELL.ID),
                  data = data_a, 
                  control = lmerControl(optimizer = "bobyqa"))  
  tictoc::toc()
  

  for (j in 1:n_distinct(data0$MONTH)) {
    for (k in 1:n_distinct(data0$M.YEAR)) {
      count <- count + 1
      
      data0$PRED[count] = exp(predict(model_a,
                                      data.frame(MONTH = data0$MONTH[count],
                                                 M.YEAR = data0$M.YEAR[count]),
                                      re.form = NA, type = "response"))
    }
  }
} 

data0 <- data0 %>% 
  left_join(timeline)



```

-   In normal circumstances, checklists become longer in the winter, and shorter in the monsoon. The only notable change during the pandemic at the national level was low checklist duration in April--June, due to the national lockdown/second wave.\
-   A point of interest is that the average checklist duration varied greatly between states. Among the 4 compared here, Kerala on average had shortest lists, followed by Karnataka and then Maharashtra.\
-   Patterns somewhat similar to those of birding distance. Generally, briefly reduced during the peak months.

### List length

Not "per observer", as this metric from data POV.

```{r d08_length, cache=TRUE, message=FALSE}

anal_name <- "d08_length"

##### Final analysis: national GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
# taking data from all states instead of just chosen 4
data0_a <- data0_MY_slice_G %>% 
  tidyr::expand(nesting(MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA)

data_a <- data0_MY_slice_G %>% 
  group_by(M.YEAR, MONTH, CELL.ID, SAMPLING.EVENT.IDENTIFIER) %>% 
  dplyr::summarise(LENGTH = NO.SP) %>%
  ungroup()

tictoc::tic(glue("GLMM for India"))
model_a <- glmer(LENGTH ~ M.YEAR + M.YEAR:MONTH + (1|CELL.ID),
                 data = data_a, family = poisson,
                 nAGQ = 0, control = glmerControl(optimizer = "bobyqa")) 
tictoc::toc() # 82 sec


tictoc::tic(glue("Bootstrapped predictions for India"))
prediction <- split_par_boot(model = model_a, 
                             new_data = data0_a, 
                             new_data_string = "data0_a", 
                             mode = "extra")
tictoc::toc() # 5059 sec (84 mins)


for (i in 1:length(data0_a$MONTH)) {
  
  data0_a$PRED.LINK[i] <- median(na.omit(prediction[,i]))
  data0_a$SE.LINK[i] <- sd(na.omit(prediction[,i]))

}

data0_a <- data0_a %>% 
  mutate(PRED = exp(PRED.LINK),
         CI.L = exp(PRED.LINK - SE.LINK)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)

##### Final analysis: statewise GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
data0_b <- data0_MY_slice_G %>% 
  filter(STATE %in% anal_states[1,]) %>% 
  tidyr::expand(nesting(STATE, MONTH, M.YEAR)) %>% 
  mutate(PRED.LINK = NA,
         SE.LINK = NA,
         STATE = factor(STATE, levels = anal_states[1,])) %>% 
  arrange(STATE)


for (i in 1:4) { # for each state
  
  data0_b2 <- data0_b %>% filter(STATE == anal_states[, i])
    
  data_b <- data0_MY_slice_G %>% 
    filter(STATE == anal_states[, i]) %>% 
    group_by(M.YEAR, MONTH, CELL.ID, SAMPLING.EVENT.IDENTIFIER) %>% 
    dplyr::summarise(LENGTH = NO.SP) %>%
    ungroup()
  
  tictoc::tic(glue("GLMM for {anal_states[, i]}"))
  model_b <- glmer(LENGTH ~ M.YEAR + M.YEAR:MONTH + (1|CELL.ID),
                   data = data_b, family = poisson,
                   nAGQ = 0, control = glmerControl(optimizer = "bobyqa")) 
  tictoc::toc() #

  
  tictoc::tic(glue("Bootstrapped predictions for {anal_states[, i]}"))
  prediction <- boot_conf_GLMM(model_b,
                               new_data = data0_b2,
                               new_data_string = "data0_b2",
                               nsim = 1000)
  tictoc::toc() #


  
  for (j in 1:length(data0_b2$MONTH)) {
    
    data0_b2$PRED.LINK[j] <- median(na.omit(prediction[,j]))
    data0_b2$SE.LINK[j] <- sd(na.omit(prediction[,j]))
    
  }
  
  data0_b <- data0_b %>% 
    left_join(data0_b2, by = c("STATE", "MONTH", "M.YEAR")) %>% 
    transmute(MONTH = MONTH,
              M.YEAR = M.YEAR,
              STATE = STATE,
              PRED.LINK = ifelse(!is.na(PRED.LINK.y), PRED.LINK.y, PRED.LINK.x),
              SE.LINK = ifelse(!is.na(SE.LINK.y), SE.LINK.y, SE.LINK.x))
  
} 

data0_b <- data0_b %>% 
  mutate(PRED = exp(PRED.LINK),
         CI.L = exp(PRED.LINK - SE.LINK)) %>% 
  mutate(SE = PRED - CI.L) %>% 
  mutate(CI.U = PRED + SE) %>% 
  left_join(timeline)

##### Saving analysis objects ####

save(data0_a, data_a, model_a, data0_b, data_b, model_b, 
     file = glue("outputs/{anal_name}.RData"))

##### Graphs ####

plot_a <- ggplot(data0_a, 
                 aes(MONTH, PRED, colour = M.YEAR)) +
  labs(title = "National-level models",
       x = "Month", y = "Predicted list length") +
  geom_point(size = 2, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                size = 1, width = 0.3, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Migratory\nyear")

ggsave(filename = glue("03_wrap_figs/{anal_name}_a.png"), plot = plot_a,
       dpi = 300, width = 11, height = 6, units = "in")

plot_b <- ggplot(data0_b, 
                 aes(MONTH, PRED, colour = M.YEAR)) +
  facet_wrap(~ STATE, ncol = 2, scales = "free_y") +
  labs(title = "State-level models",
       x = "Month", y = "Predicted list length") +
  geom_point(size = 3, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                size = 1.5, width = 0.4, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Migratory\nyear")

ggsave(filename = glue("03_wrap_figs/{anal_name}_b.png"), plot = plot_b,
       dpi = 300, width = 22, height = 13, units = "in")

```

-   Overall, slight decrease during the peak period.\
-   Kerala didn't show any change at all.\
-   The peak months brought average list length in other states to around 10-11 species, which in Kerala's case already used to be the case (shorter lists).

### Spatial spread and coverage

1.  Urban:non-urban ratio in birding effort
    -   Proportion of lists that are urban per grid cell\
    -   Proportion of lists that are urban per grid cell GLMM\
2.  Spatial coverage (min. 10 lists per grid cell)
    -   Proportion of total cells in country/state covered across months
    -   Proportion of total cells in country/state covered across months GLMM\
3.  Spatial spread/evenness (25kmx25km cells; across 9 months) Large spatial and temporal scale---no STATE or MONTH/M.YEAR in question.
    -   Raw change in no. of lists per district
    -   Proportional change in no. of lists per district (only declines)
    -   Raw change in grid coverage per district
    -   Proportional change in grid coverage per district (only declines)

```{r s_UNU, cache=TRUE, message=FALSE}

##### Proportion of urban lists per grid cell ####

temp <- data0_MY_slice_G %>% 
  group_by(COVID, M.YEAR, MONTH, CELL.ID) %>% # state is meaningless cos CELL.ID
  filter(URBAN == 1) %>% 
  dplyr::summarise(U.LISTS = n_distinct(GROUP.ID)) %>% 
  ungroup()

urban_lists <- data0_MY_slice_G %>% 
  group_by(COVID, M.YEAR, MONTH, CELL.ID) %>%
  dplyr::summarise(TOT.LISTS = n_distinct(GROUP.ID)) %>% 
  left_join(temp) %>% 
  group_by(COVID, M.YEAR, MONTH, CELL.ID) %>%
  dplyr::summarise(U.LISTS = replace_na(U.LISTS, 0),
                   PROP.U = U.LISTS/TOT.LISTS,
                   SE = sqrt((PROP.U)*(1 - PROP.U)/TOT.LISTS)) %>% 
  group_by(COVID, M.YEAR, MONTH) %>% 
  dplyr::summarise(PROP.U = mean(PROP.U),
                   SE = sqrt(sum((SE)^2))/n(),
                   CI.L = PROP.U - 1.96*SE,
                   CI.U = PROP.U + 1.96*SE)

rm(temp)


ggplot(urban_lists, aes(MONTH, PROP.U, colour = COVID)) + 
  scale_x_continuous(breaks = 1:12,
                     labels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", 
                                "Sep", "Oct", "Nov", "Dec")) + 
  annotate("rect", xmin = 2.5, xmax = 9.5, ymin = -Inf, ymax = Inf, 
            fill = "#E0DDE3", col = NA, alpha = 0.5) +
  geom_point(size = 4, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                size = 1.75, width = 0.7, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette,
                      name = "Period", 
                      labels = c("Before", "During (2020)", "During (2021)", "After")) +
  labs(title = "2020 lockdown restricted birders to urban areas",
       x = "Month", y = "Proportion of urban lists per grid cell") -> s_UNU

s_UNU


ggsave("03_wrap_figs/10a_s_UNU.png", 
       plot = s_UNU,
       width = 13, height = 7, units = "in")


##### Final analysis: GLMM of urban birding using weighted proportions ####

# https://github.com/lme4/lme4/issues/281
# Issue with high number of zeroes (or hence low proportion values) and back-transformation of linear variable without accounting for random variation
# So, need to include random effects in prediction.

data_urban <- data0_MY_slice_G %>% 
  group_by(M.YEAR, MONTH, COUNTY, CELL.ID) %>% 
  filter(URBAN == 1) %>% 
  dplyr::summarise(U.LISTS = n_distinct(GROUP.ID)) %>% 
  right_join(data0_MY_slice_G) %>% 
  group_by(M.YEAR, MONTH, COUNTY, CELL.ID) %>% 
  dplyr::summarise(TOT.LISTS = n_distinct(GROUP.ID),
                   U.LISTS = replace_na(min(U.LISTS), 0),
                   PROP.U = round(U.LISTS/TOT.LISTS, 4)) %>% 
  ungroup()
  
counties <- data_urban %>% distinct(COUNTY, CELL.ID)

# no MONTH main effect unlike in birds model
tictoc::tic("UNU GLMM using weighted proportions")
model_urban <- glmer(PROP.U ~ M.YEAR + M.YEAR:MONTH + (1|COUNTY/CELL.ID), 
                      weights = TOT.LISTS,
                      data = data_urban, family = binomial(link = "cloglog"),
                      nAGQ = 0, control = glmerControl(optimizer = "bobyqa")) # 119 sec
tictoc::toc()

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
urban1 <- data_urban %>% 
  tidyr::expand(nesting(MONTH, M.YEAR, COUNTY, CELL.ID)) %>% 
  filter(!is.na(COUNTY)) %>% 
  mutate(PROP.U.PRED = predict(model_urban, data.frame(MONTH, M.YEAR, COUNTY, CELL.ID),
                               type = "response")) %>% 
  group_by(M.YEAR, MONTH) %>% 
  summarise(SE = sd(PROP.U.PRED)/sqrt(n()),
            PROP.U.PRED = mean(PROP.U.PRED)) %>% 
  summarise(PROP.U.PRED = mean(PROP.U.PRED),
            SE = sqrt(sum((SE)^2))/n(),
            CI.L = PROP.U.PRED - 1.96*SE,
            CI.U = PROP.U.PRED + 1.96*SE)

urban2 <- data_urban %>% 
  tidyr::expand(nesting(MONTH, M.YEAR, COUNTY, CELL.ID)) %>% 
  filter(!is.na(COUNTY)) %>% 
  mutate(PROP.U.PRED = predict(model_urban, data.frame(MONTH, M.YEAR, COUNTY, CELL.ID),
                               type = "response")) %>% 
  filter(MONTH %in% 4:5) %>% 
  group_by(M.YEAR, MONTH) %>% 
  summarise(SE = sd(PROP.U.PRED)/sqrt(n()),
            PROP.U.PRED = mean(PROP.U.PRED)) %>% 
  summarise(PROP.U.PRED = mean(PROP.U.PRED),
            SE = sqrt(sum((SE)^2))/n(),
            CI.L = PROP.U.PRED - 1.96*SE,
            CI.U = PROP.U.PRED + 1.96*SE)


ggplot(urban2, aes(M.YEAR, PROP.U.PRED)) +
    labs(title = "For the months of April and May",
         x = "Migratory year", y = "Predicted urban birding proportion") +
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                  size = 1.5, width = 0.2, position = position_dodge(0.5))

ggplot(urban1, aes(M.YEAR, PROP.U.PRED)) +
    labs(title = "For all months",
         x = "Migratory year", y = "Predicted urban birding proportion") +
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
                  size = 1.5, width = 0.2, position = position_dodge(0.5))


```

```{r s_cover, cache=TRUE, message=FALSE}

##### Proportion of total grid cells covered ####

cover_sw <- data0_MY_slice_G %>% 
  group_by(STATE) %>% 
  mutate(TOT.CELLS = n_distinct(CELL.ID)) %>% 
  group_by(COVID, M.YEAR, MONTH, STATE, CELL.ID) %>% 
  dplyr::summarise(TOT.CELLS = min(TOT.CELLS),
                   N.LISTS = n_distinct(GROUP.ID)) %>% 
  filter(N.LISTS >= 10) %>% 
  group_by(COVID, M.YEAR, MONTH, STATE) %>% 
  dplyr::summarise(TOT.CELLS = min(TOT.CELLS),
                   NO.CELLS = n_distinct(CELL.ID),
                   PROP.CELLS = NO.CELLS/TOT.CELLS,
                   SE = sqrt((PROP.CELLS)*(1 - PROP.CELLS)/TOT.CELLS),
                   CI.L = PROP.CELLS - 1.96*SE,
                   CI.U = PROP.CELLS + 1.96*SE)

cover_nw <- data0_MY_slice_G %>% 
  ungroup() %>% 
  mutate(TOT.CELLS = n_distinct(CELL.ID)) %>% 
  group_by(COVID, M.YEAR, MONTH, CELL.ID) %>% 
  dplyr::summarise(TOT.CELLS = min(TOT.CELLS),
                   N.LISTS = n_distinct(GROUP.ID)) %>% 
  filter(N.LISTS >= 10) %>% 
  group_by(COVID, M.YEAR, MONTH) %>% 
  dplyr::summarise(TOT.CELLS = min(TOT.CELLS),
                   NO.CELLS = n_distinct(CELL.ID),
                   PROP.CELLS = NO.CELLS/TOT.CELLS,
                   SE = sqrt((PROP.CELLS)*(1 - PROP.CELLS)/TOT.CELLS),
                   CI.L = PROP.CELLS - 1.96*SE,
                   CI.U = PROP.CELLS + 1.96*SE)


((ggplot(cover_nw, aes(MONTH, PROP.CELLS, colour = COVID)) + 
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "National level",
         x = "Month", y = "Birded proportion")) /
((ggplot(filter(cover_sw, STATE == "Kerala"), 
        aes(MONTH, PROP.CELLS, colour = COVID)) + 
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Kerala",
         x = "Month", y = "Birded proportion")) |
(ggplot(filter(cover_sw, STATE == "Karnataka"), 
        aes(MONTH, PROP.CELLS, colour = COVID)) + 
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Karnataka",
         x = "Month", y = "Birded proportion"))) /
((ggplot(filter(cover_sw, STATE == "Maharashtra"), 
        aes(MONTH, PROP.CELLS, colour = COVID)) + 
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Maharashtra",
         x = "Month", y = "Birded proportion")) |
(ggplot(filter(cover_sw, STATE == "Assam"), 
        aes(MONTH, PROP.CELLS, colour = COVID)) + 
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Assam",
         x = "Month", y = "Birded proportion")))) +
plot_layout(guides = "collect") +
plot_annotation(title = "Change in spatial coverage of monthly birding with the pandemic",
         subtitle = "Proportion of total grid cells (24kmx24km) having birding activity") -> s_cover

s_cover

ggsave("03_wrap_figs/11a_s_cover.png", 
       plot = s_cover,
       width = 9, height = 9, units = "in")


rm(cover_sw, cover_nw, s_cover)


##### Final analysis: statewise GLMMs ####

# dataframe with empty column to populate with looped values
# total rows: product of distinct values of predictors
data0 <- data0_MY_slice_G %>% 
  filter(STATE %in% anal_states[1,]) %>% 
  tidyr::expand(nesting(STATE, MONTH, M.YEAR)) %>% 
  mutate(PRED = NA,
         STATE = factor(STATE, levels = anal_states[1,])) %>% 
  arrange(STATE)

count <- 0
for (i in 1:4) { # for each state
  
  data_a <- data0_MY_slice_G %>% 
    filter(STATE == anal_states[, i]) %>% 
    select(M.YEAR, MONTH, CELL.ID, GROUP.ID) %>% 
    tidyr::complete(M.YEAR, MONTH, CELL.ID) %>% 
    group_by(M.YEAR, MONTH, CELL.ID) %>% 
    dplyr::summarise(COVERED = if_else(n_distinct(GROUP.ID) >= 10, 1, 0))
  
  tictoc::tic(glue::glue("GLMM for {anal_states[, i]}"))
  model_a <- glmer(COVERED ~ M.YEAR + M.YEAR:MONTH + (1|CELL.ID),
                   data = data_a, family = binomial(link = "cloglog"),
                   nAGQ = 0, control = glmerControl(optimizer = "bobyqa"))  
  tictoc::toc()
  
  for (j in 1:n_distinct(data0$MONTH)) {
    for (k in 1:n_distinct(data0$M.YEAR)) {
      count <- count + 1
      
      data0$PRED[count] = predict(model_a,
                                  data.frame(MONTH = data0$MONTH[count],
                                             M.YEAR = data0$M.YEAR[count]),
                                  re.form = NA, type = "response")
    }
  }
} 

data0 <- data0 %>% 
  left_join(timeline)


(ggplot(filter(data0, STATE == anal_states$a), 
       aes(MONTH, PRED, colour = COVID)) +
  labs(title = anal_states$a,
       x = "Month", y = "Predicted grid cell coverage") +
  geom_point(size = 3, position = position_dodge(0.5)) +
  # geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
  #               size = 1.5, width = 0.2, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Period")) /
(ggplot(filter(data0, STATE == anal_states$b), 
       aes(MONTH, PRED, colour = COVID)) +
  labs(title = anal_states$b,
       x = "Month", y = "Predicted grid cell coverage") +
  geom_point(size = 3, position = position_dodge(0.5)) +
  # geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
  #               size = 1.5, width = 0.2, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Period")) /
(ggplot(filter(data0, STATE == anal_states$c), 
       aes(MONTH, PRED, colour = COVID)) +
  labs(title = anal_states$c,
       x = "Month", y = "Predicted grid cell coverage") +
  geom_point(size = 3, position = position_dodge(0.5)) +
  # geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
  #               size = 1.5, width = 0.2, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Period")) /
(ggplot(filter(data0, STATE == anal_states$d), 
       aes(MONTH, PRED, colour = COVID)) +
  labs(title = anal_states$d,
       x = "Month", y = "Predicted grid cell coverage") +
  geom_point(size = 3, position = position_dodge(0.5)) +
  # geom_errorbar(aes(ymin = CI.L, ymax = CI.U),
  #               size = 1.5, width = 0.2, position = position_dodge(0.5)) +
  scale_colour_manual(values = covid_palette, name = "Period"))

```

For spread, we will not consider change in number or proportion of lists per grid cells because there will be too much noise at that fine a scale. Here, districts provide a nice compromise: large enough to track change, small enough to inform us about local patterns. For grid coverage, only those districts that have a minimum of 5 grid cells will be considered.

```{r s_spread, cache=TRUE, message=FALSE}

load("data/maps_gridmapg1_IN.RData") # all cells within India

gridmapg1_IN <- gridmapg1_IN %>% 
  # setting CRS for join in next step
  st_set_crs(value = st_crs(districtmap))

# creating object linking grid cells to districts
grid_dist <- districtmap %>% 
  st_as_sf() %>% 
  dplyr::select(dtname) %>% 
  rename(DISTRICT.NAME = dtname) %>% 
  st_join(gridmapg1_IN)
# losing some districts and grid cells, but doesn't matter. 
# Will explore patterns with existing.

# Ensuring that a grid cell is only linked with one district
grid_dist_links <- grid_dist %>% 
  st_drop_geometry() %>% 
  group_by(CELL.ID) %>% 
  slice_sample() %>% 
  group_by(DISTRICT.NAME) %>% 
  mutate(NO.CELLS.TOT = n_distinct(CELL.ID)) %>% 
  ungroup()

# # distribution of number of cells covered, across districts
# x <- grid_dist_links %>% 
#   group_by(DISTRICT.NAME) %>% 
#   summarise(NO.CELLS = n_distinct(CELL.ID)) %>% 
#   group_by(NO.CELLS) %>% 
#   summarise(NO.DISTRICTS = n())

grid_dist <- grid_dist %>% 
  right_join(grid_dist_links)


temp0 <- data0_MY_slice_G %>% 
  # selecting only nine months (AFT has only nine)
  filter(MONTH %in% month_compar$MONTH) %>% 
  # combining the two DUR periods
  mutate(COVID = as.character(COVID)) %>% 
  mutate(COVID = case_when(COVID %in% c("DUR_20","DUR_21") ~ "DUR",
                           TRUE ~ COVID)) %>% 
  mutate(COVID = factor(COVID, levels = c("BEF", "DUR", "AFT"))) %>% 
  # although data has fewer cells than grid_dist, using inner so only those cells with 
  # established district links will be considered (removes some cells and districts)
  dplyr::select(-DISTRICT) %>% # removing to avoid confusion
  inner_join(grid_dist)

# considering only districts with at least 5 grid cells for grid coverage
temp1 <- temp0 %>% 
  filter(NO.CELLS.TOT >= 5) %>% 
  # summarising metrics of interest
  group_by(COVID, DISTRICT.NAME, NO.CELLS.TOT) %>% 
  summarise(NO.CELLS = n_distinct(CELL.ID)) %>% 
  ungroup() %>% 
  complete(COVID, nesting(DISTRICT.NAME, NO.CELLS.TOT),
           fill = list(NO.CELLS = 0)) %>% 
  mutate(GRID.COV = 100*NO.CELLS/NO.CELLS.TOT) %>% 
  # moving COVID to columns
  dplyr::select(-NO.CELLS)

# for grid coverage per district with threshold
temp2 <- temp0 %>% 
  filter(NO.CELLS.TOT >= 5) %>% 
  # summarising metrics of interest
  group_by(COVID, DISTRICT.NAME, NO.CELLS.TOT, CELL.ID) %>% 
  summarise(CELL.LISTS = n_distinct(GROUP.ID)) %>% 
  # threshold of 5 lists in a grid cell for the cell to be considered "covered"
  filter(CELL.LISTS >= 5) %>% 
  summarise(NO.CELLS = n_distinct(CELL.ID)) %>% 
  ungroup() %>% 
  complete(COVID, nesting(DISTRICT.NAME, NO.CELLS.TOT),
           fill = list(NO.CELLS = 0)) %>% 
  mutate(GRID.COV.T = 100*NO.CELLS/NO.CELLS.TOT) %>% 
  # moving COVID to columns
  dplyr::select(-NO.CELLS)


data_spread0 <- temp0 %>% 
  # summarising metrics of interest
  group_by(COVID, DISTRICT.NAME, NO.CELLS.TOT) %>% 
  summarise(NO.LISTS = n_distinct(GROUP.ID)) %>% 
  ungroup() %>% 
  complete(COVID, nesting(DISTRICT.NAME, NO.CELLS.TOT),
           fill = list(NO.LISTS = 0)) %>% 
  left_join(temp1) %>% 
  left_join(temp2) %>% 
  pivot_longer(cols = c("NO.LISTS", "GRID.COV", "GRID.COV.T"),
               names_to = "METRIC", values_to = "VALUE") %>% 
  # some NAs produced for grid coverage because those districts don't qualify for coverage
  # analysis but present in number of lists analysis, so need to remove them
  filter(!(is.na(VALUE))) %>% 
  pivot_wider(names_from = "COVID", values_from = "VALUE") %>% 
  # calculating change (produces NA for x == 0 & y == 0 which need to be removed)
  mutate(RAW.CHANGE1 = s_spread_change(BEF, DUR),
         RAW.CHANGE2 = s_spread_change(DUR, AFT),
         PROP.CHANGE1a = s_spread_propchange(METRIC, BEF, DUR),
         PROP.CHANGE1b = s_spread_propchange(METRIC, DUR, AFT),
         PROP.CHANGE2a = s_spread_propchange(METRIC, DUR, BEF),
         PROP.CHANGE2b = s_spread_propchange(METRIC, AFT, DUR)) %>% 
  left_join(grid_dist)

transition_names <- data.frame(T.CODE = c("T1", "T2", "T3", "T4"),
                               T.LABEL = c("Before to During", "During to After",
                                           "During to Before", "After to During"))


##### Change in birding effort per district ####

# 1. map of raw change
# 2. with SEs of raw change
# 3. map of proportional change

# 1. map (to give an idea of overall clustering)

data_spread1 <- data_spread0 %>% 
  filter(METRIC == "NO.LISTS") %>% 
  distinct(DISTRICT.NAME, geometry, RAW.CHANGE1, RAW.CHANGE2) %>% 
  # pivoting longer for facetting
  pivot_longer(cols = c("RAW.CHANGE1", "RAW.CHANGE2"),
               names_to = "METRIC", values_to = "VALUE") %>% 
  mutate(T.CODE = case_when(str_detect(METRIC, "1") ~ "T1",
                            str_detect(METRIC, "2") ~ "T2")) %>% 
  left_join(transition_names)

s_spread_map <- ggplot(data_spread1) +
  geom_polygon(data = indiamap,
               aes(long, lat, group = group),
               fill = "#ACACAC", colour = "black", size = 0.4) +
  geom_sf(aes(fill = VALUE, geometry = geometry), col ="#ACACAC", size = 0.1) +
  facet_wrap(~ T.LABEL) +
  # scale_fill_continuous_divergingx(palette = "RdBu", mid = 0,
  #                                  n_interp = 7, na.value = "grey") +
  scale_fill_stepsn(colours = RColorBrewer::brewer.pal(n = 7, name = "RdBu"),
                    breaks = c(-1000, -500, -100, 0, 100, 500, 1000),
                    values = scales::rescale(c(-4134, -1000, -500, -100, 0, 
                                               100, 500, 1000, 7848)), 
                    limits = c(-4134, 7848),
                    na.value = "#ACACAC") +
  labs(x = "Longitude", y = "Latitude",
       fill = "Difference in\nno. of lists",
       title = "Change in no. of lists per district in transition periods",
       subtitle = "Grey: districts not considered in analysis")
# not considered can be either because both time periods are zero, or if generally no 
# district-grid cell link present

ggsave("03_wrap_figs/10c_s_spread_map.png", 
       plot = s_spread_map,
       dpi = 300, width = 14, height = 8, units = "in")



# 2. with SEs

set.seed(23) # for bootstrap

# not directly using data_spread0 object because backtransforming after bootstrapping mean 
# and SE is not wise
data_spread2 <- data_spread1 %>% 
  # removing NA cells (when both periods of the transition are zero)
  filter(!is.na(VALUE)) %>% 
  group_by(T.CODE, T.LABEL) %>% 
  # this gives B number of means of bootstrapped samples
  dplyr::summarise(VALUE = boot_conf(x = VALUE)) %>% 
  group_by(T.CODE, T.LABEL) %>% 
  dplyr::summarise(CI.L = stats::quantile(VALUE, 0.025), # Obtain the CIs
                   CI.U = stats::quantile(VALUE, 0.975),
                   VALUE = median(VALUE)) 

s_spread_rawchange <- ggplot(data_spread2, aes(x = T.LABEL, y = VALUE)) + 
  geom_point(size = 4, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                size = 1.75, width = 0.08, position = position_dodge(0.5)) +
  # scale_y_continuous(limits = c(1.1, 2.3), breaks = seq(1, 3, 0.2)) +
  labs(title = "Net change in birding effort (no. of lists) across districts\nin transition periods",
       x = "Transition", y = "Difference in no. of lists") 

ggsave("03_wrap_figs/10c_s_spread_rawchange.png", 
       plot = s_spread_rawchange,
       dpi = 300, width = 6, height = 9, units = "in")

# is DUR-AFT really lower than BEF-DUR?
ggplot(data_spread1) +
  geom_histogram(aes(VALUE)) +
  facet_wrap(~ T.LABEL)


# 3. map

# forward direction
data_spread3a <- data_spread0 %>% 
  filter(METRIC == "NO.LISTS") %>% 
  distinct(DISTRICT.NAME, geometry, PROP.CHANGE1a, PROP.CHANGE1b) %>% 
  # pivoting longer for facetting
  pivot_longer(cols = c("PROP.CHANGE1a", "PROP.CHANGE1b"),
               names_to = "METRIC", values_to = "VALUE") %>% 
  mutate(T.CODE = case_when(str_detect(METRIC, "a") ~ "T1",
                            str_detect(METRIC, "b") ~ "T2")) %>% 
  left_join(transition_names) %>% 
  # keeping only negative change
  mutate(VALUE = ifelse(VALUE < 0, VALUE, NA_real_))

# backward direction
data_spread3b <- data_spread0 %>% 
  filter(METRIC == "NO.LISTS") %>% 
  distinct(DISTRICT.NAME, geometry, PROP.CHANGE2a, PROP.CHANGE2b) %>% 
  # pivoting longer for facetting
  pivot_longer(cols = c("PROP.CHANGE2a", "PROP.CHANGE2b"),
               names_to = "METRIC", values_to = "VALUE") %>% 
  mutate(T.CODE = case_when(str_detect(METRIC, "a") ~ "T3",
                            str_detect(METRIC, "b") ~ "T4")) %>% 
  left_join(transition_names) %>% 
  # keeping only negative change
  mutate(VALUE = ifelse(VALUE < 0, VALUE, NA_real_)) %>% 
  # order
  mutate(T.LABEL = factor(T.LABEL, levels = c("After to During", "During to Before")))


s_spread_mapprop <- (ggplot(data_spread3a) +
  geom_polygon(data = indiamap,
               aes(long, lat, group = group),
               fill = "white", colour = "black", size = 0.4) +
  geom_sf(aes(fill = VALUE, geometry = geometry), col ="#ACACAC", size = 0.1) +
  facet_wrap(~ T.LABEL) +
  # scale_fill_continuous_divergingx(palette = "RdBu", mid = 0,
  #                                  n_interp = 7, na.value = "grey") +
  scale_fill_steps2(low = viridisLite::cividis(5, direction = -1)[1],
                    mid = viridisLite::cividis(5, direction = -1)[3],
                    high = viridisLite::cividis(5, direction = -1)[5],
                    midpoint = -0.45,
                    breaks = c(-1, -0.9, -0.65, -0.45, -0.25, -0.1, -0),
                    limits = c(-1, 0),
                    na.value = "#ACACAC") +
  labs(x = "Longitude", y = "Latitude",
       fill = "Proportional change")) /
  (ggplot(data_spread3b) +
  geom_polygon(data = indiamap,
               aes(long, lat, group = group),
               fill = "white", colour = "black", size = 0.4) +
  geom_sf(aes(fill = VALUE, geometry = geometry), col ="#ACACAC", size = 0.1) +
  facet_wrap(~ T.LABEL) +
  # scale_fill_viridis_b(option = "cividis", direction = -1, na.value = "grey",
  #                      values = c(0.1, 0.25, 0.45, 0.65, 0.9)) +
  scale_fill_steps2(low = viridisLite::cividis(5, direction = -1)[1],
                    mid = viridisLite::cividis(5, direction = -1)[3],
                    high = viridisLite::cividis(5, direction = -1)[5],
                    midpoint = -0.45,
                    breaks = c(-1, -0.9, -0.65, -0.45, -0.25, -0.1, -0),
                    limits = c(-1, 0),
                    na.value = "#ACACAC") +
  labs(x = "Longitude", y = "Latitude",
       fill = "Proportional change")) +
  plot_layout(guides = "collect") +
  plot_annotation(title = "Proportional declines in no. of lists per district in transition periods (only when N1 >= 10)",
                  subtitle = "Grey: districts with positive proportional change\nWhite: districts not considered in analysis")

ggsave("03_wrap_figs/10c_s_spread_mapprop.png", 
       plot = s_spread_mapprop,
       dpi = 300, width = 14, height = 15, units = "in")


##### Change in grid coverage per district (without & with threshold) ####

# 1. map of raw change
# 2. with SEs of raw change
# 3. map of proportional change

coverage_types <- data.frame(METRIC = c("GRID.COV", "GRID.COV.T"),
                             METRIC.LABEL = c("Coverage (%)", "Coverage with threshold (%)"))

# 1. map (to give an idea of overall clustering)

data_spread4 <- data_spread0 %>% 
  filter(METRIC == "GRID.COV" | METRIC == "GRID.COV.T") %>% 
  distinct(METRIC, DISTRICT.NAME, geometry, RAW.CHANGE1, RAW.CHANGE2) %>% 
  # pivoting longer for facetting
  pivot_longer(cols = c("RAW.CHANGE1", "RAW.CHANGE2"),
               names_to = "CHANGE.TYPE", values_to = "VALUE") %>% 
  mutate(T.CODE = case_when(str_detect(CHANGE.TYPE, "1") ~ "T1",
                            str_detect(CHANGE.TYPE, "2") ~ "T2")) %>% 
  left_join(transition_names) %>% 
  left_join(coverage_types)

s_spread_gridcov_map <- ggplot(data_spread4) +
  geom_polygon(data = indiamap,
               aes(long, lat, group = group),
               fill = "#ACACAC", colour = "black", size = 0.4) +
  geom_sf(aes(fill = VALUE, geometry = geometry), col ="#ACACAC", size = 0.1) +
  facet_grid(METRIC.LABEL ~ T.LABEL, switch = "y") +
  scale_fill_stepsn(colours = RColorBrewer::brewer.pal(n = 7, name = "RdBu"),
                    breaks = c(-40, -25, -10, 0, 10, 25, 40),
                    values = scales::rescale(c(-100, -40, -25, -10, 0, 10, 25, 40, 100)), 
                    limits = c(-100, 100),
                    na.value = "#ACACAC") +
  labs(x = "Longitude", y = "Latitude",
       fill = "Difference in\ngrid coverage",
       title = "Change in grid coverage per district in transition periods",
       subtitle = "Grey: districts not considered in analysis")

ggsave("03_wrap_figs/10c_s_spread_gridcov_map.png", 
       plot = s_spread_gridcov_map,
       dpi = 300, width = 14, height = 14, units = "in")


# 2. with SEs

set.seed(23) # for bootstrap

data_spread5 <- data_spread4 %>% 
  # removing NA cells (when both periods of the transition are zero)
  filter(!is.na(VALUE)) %>% 
  group_by(METRIC, METRIC.LABEL, T.CODE, T.LABEL) %>% 
  # this gives B number of means of bootstrapped samples
  dplyr::summarise(VALUE = boot_conf(x = VALUE)) %>% 
  group_by(METRIC, METRIC.LABEL, T.CODE, T.LABEL) %>% 
  dplyr::summarise(CI.L = stats::quantile(VALUE, 0.025), # Obtain the CIs
                   CI.U = stats::quantile(VALUE, 0.975),
                   VALUE = median(VALUE)) 

s_spread_gridcov_rawchange <- ggplot(data_spread5, aes(x = T.LABEL, y = VALUE)) + 
  facet_wrap(~ METRIC.LABEL, nrow = 2) +
  geom_point(size = 4, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                size = 1.75, width = 0.08, position = position_dodge(0.5)) +
  # scale_y_continuous(limits = c(1.1, 2.3), breaks = seq(1, 3, 0.2)) +
  labs(title = "Net change in grid coverage across districts\nin transition periods",
       x = "Transition", y = "Difference in grid coverage") 

ggsave("03_wrap_figs/10c_s_spread_gridcov_rawchange.png", 
       plot = s_spread_gridcov_rawchange,
       dpi = 300, width = 6, height = 9, units = "in")


# 3. map

data_spread6 <- data_spread0 %>% 
  filter(METRIC == "GRID.COV" | METRIC == "GRID.COV.T") %>% 
  distinct(METRIC, DISTRICT.NAME, geometry, 
           PROP.CHANGE1a, PROP.CHANGE1b, PROP.CHANGE2a, PROP.CHANGE2b) %>% 
  # pivoting longer for facetting
  pivot_longer(cols = c("PROP.CHANGE1a", "PROP.CHANGE1b",
                        "PROP.CHANGE2a", "PROP.CHANGE2b"),
               names_to = "CHANGE.TYPE", values_to = "VALUE") %>% 
  mutate(T.CODE = case_when(str_detect(CHANGE.TYPE, "1a") ~ "T1",
                            str_detect(CHANGE.TYPE, "1b") ~ "T2",
                            str_detect(CHANGE.TYPE, "2a") ~ "T3",
                            str_detect(CHANGE.TYPE, "2b") ~ "T4")) %>% 
  left_join(transition_names) %>% 
  left_join(coverage_types) %>% 
  # keeping only negative change
  mutate(VALUE = ifelse(VALUE < 0, VALUE, NA_real_)) %>% 
  mutate(T.LABEL = factor(T.LABEL, levels = c("Before to During", "During to After",
                                              "After to During", "During to Before")))

# with the threshold, the IQR of proportional change has increased even though range is smaller
# i.e., the distribution is much more rounded
# this results in more districts with higher declines, but what's important here is to
# compare bef-dur with aft-dur and see which districts overlap---not many
# then compare these two with dur-aft and dur-bef respectively to check whether changes are 
# only in one direction---evidently not

s_spread_gridcov_mapprop_a <- ggplot(data_spread6 %>% 
                                       filter(METRIC == "GRID.COV")) +
  geom_polygon(data = indiamap,
               aes(long, lat, group = group),
               fill = "white", colour = "black", size = 0.4) +
  geom_sf(aes(fill = VALUE, geometry = geometry), col ="#ACACAC", size = 0.1) +
  facet_wrap(~ T.LABEL, ncol = 2) +
  scale_fill_steps2(low = viridisLite::cividis(5, direction = -1)[1],
                    mid = viridisLite::cividis(5, direction = -1)[3],
                    high = viridisLite::cividis(5, direction = -1)[5],
                    midpoint = -0.45,
                    breaks = c(-1, -0.9, -0.65, -0.45, -0.25, -0.1, -0),
                    limits = c(-1, 0),
                    na.value = "#ACACAC") +
  labs(x = "Longitude", y = "Latitude",
       fill = "Proportional change",
       title = "Proportional declines in grid coverage per district in transition periods",
       subtitle = "Grey: districts with positive proportional change\nWhite: districts not considered in analysis")

ggsave("03_wrap_figs/10c_s_spread_gridcov_mapprop_a.png", 
       plot = s_spread_gridcov_mapprop_a,
       dpi = 300, width = 14, height = 14, units = "in")

s_spread_gridcov_mapprop_b <- ggplot(data_spread6 %>% 
                                       filter(METRIC == "GRID.COV.T")) +
  geom_polygon(data = indiamap,
               aes(long, lat, group = group),
               fill = "white", colour = "black", size = 0.4) +
  geom_sf(aes(fill = VALUE, geometry = geometry), col ="#ACACAC", size = 0.1) +
  facet_wrap(~ T.LABEL, ncol = 2) +
  scale_fill_steps2(low = viridisLite::cividis(5, direction = -1)[1],
                    mid = viridisLite::cividis(5, direction = -1)[3],
                    high = viridisLite::cividis(5, direction = -1)[5],
                    midpoint = -0.45,
                    breaks = c(-1, -0.9, -0.65, -0.45, -0.25, -0.1, -0),
                    limits = c(-1, 0),
                    na.value = "#ACACAC") +
  labs(x = "Longitude", y = "Latitude",
       fill = "Proportional change",
       title = "Proportional declines in grid coverage per district (with threshold) in transition periods",
       subtitle = "Grey: districts with positive proportional change\nWhite: districts not considered in analysis")

ggsave("03_wrap_figs/10c_s_spread_gridcov_mapprop_b.png", 
       plot = s_spread_gridcov_mapprop_b,
       dpi = 300, width = 14, height = 14, units = "in")

```

-   In terms of pure no. of lists, birding effort overall decreased *after the pandemic*. From the map of raw change, it is clear that more districts had negative change from DUR to AFT than from BEF to DUR. But it also seems that major and worrisome changes were in very few cases. Most importantly, there was no prominent clustering in these major worrisome changes.
-   Comparing proportional change in no. of lists in both directions, specifically BEF-DUR with AFT-DUR which tells us the effect of the pandemic, we see that most major changes (bright yellow) are in central and northern India and also that aside from a few districts in MP, UP and Bihar area there is in general little overlap between the two transitions. What this means is that while there is obvious variability in birding effort between different years, the direct effect of the pandemic on this variability (inferred from overlapping areas of high proportional decline in BEF-DUR and AFT-DUR) is not great. In fact, in some cases, some major declines in BEF-DUR are not major in AFT-DUR and vice-versa, meaning that these instead may point to annual indiosyncrasies. This is solidified by the presence of a similar number of districts showing prominent negative change in the transitions DUR-BEF and DUR-AFT.
-   Overall grid coverage across all districts did not increase during the pandemic (either stayed the same or decreased slightly, judging from CI), while it did so after. As a result, the changes in grid coverage for BEF-DUR and DUR-AFT are notably different. However, when grid coverage is defined with a threshold of 5 lists, the patterns are much more similar: looks like grid coverage during the pandemic was very similar to that before, while there was a slight (not major) increase in overall coverage after the pandemic. Looking into this deeper, it is clear that major worrisome changes (\>50% change in coverage) are actually very few, and most importantly, there aren't major spatial clusters of these major changes.
-   Like with no. of lists, in some central Indian districts grid coverage also showed major declines due to the pandemic (and bounced back after). Aside from these few districts, there is little overlap. Moreover, there are a similar number of districts with major declines in the other directions, i.e., DUR-BEF and DUR-AFT, which might be suggesting that some of this is due to annual variability.

### Temporal spread

Not "per observer", as this metric from data POV.

Since month is not considered here (and instead data from multiple months are averaged), it doesn't make sense to keep two years for BEF and AFT---they should instead also be pooled into the averaging.

Here, running models is not necessary, as we just want to visualise the patterns. Robust results for this do not tell us much. Besides, the models that can be run for this metric would be very different from those for the other metrics (no CELL.ID or OBSERVER.ID random effect, and MONTH used as random effect).

```{r t_spread_1, cache=TRUE, message=FALSE}

##### Change in DoW spread ####

t_dow_sw <- data0_MY_slice_G %>% 
  filter(MONTH %in% month_compar$MONTH) %>% 
  mutate(DAY.W = wday(OBSERVATION.DATE, 
                      # start week from Monday
                      week_start = getOption("lubridate.week.start", 1))) %>% 
  group_by(COVID, STATE, M.YEAR, MONTH) %>% 
  mutate(NO.LISTS = n_distinct(SAMPLING.EVENT.IDENTIFIER)) %>%
  group_by(COVID, DAY.W, STATE, M.YEAR, MONTH) %>% 
  dplyr::summarise(NO.LISTS = min(NO.LISTS),
                   DAY.LISTS = replace_na(n_distinct(SAMPLING.EVENT.IDENTIFIER)),
                   PROP.LISTS = DAY.LISTS/NO.LISTS,
                   SE = sqrt((PROP.LISTS)*(1 - PROP.LISTS)/NO.LISTS)) %>% 
  group_by(COVID, DAY.W, STATE) %>% 
  dplyr::summarise(PROP.LISTS = mean(PROP.LISTS),
                   SE = sqrt(sum((SE)^2))/n(),
                   CI.L = PROP.LISTS - 1.96*SE,
                   CI.U = PROP.LISTS + 1.96*SE)

t_dow_nw <- t_dow_sw %>% 
  group_by(COVID, DAY.W) %>% 
  dplyr::summarise(PROP.LISTS = mean(PROP.LISTS),
            SE = sqrt(sum((SE)^2))/n(),
            CI.L = PROP.LISTS - 1.96*SE,
            CI.U = PROP.LISTS + 1.96*SE)

(ggplot(t_dow_nw, 
       aes(as.factor(DAY.W), PROP.LISTS, colour = COVID)) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "National level",
         x = "Day", y = "Proportion of lists")) /
((ggplot(filter(t_dow_sw, STATE == "Kerala"), 
         aes(as.factor(DAY.W), PROP.LISTS, colour = COVID)) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Kerala",
         x = "Day", y = "Proportion of lists")) |
ggplot(filter(t_dow_sw, STATE == "Karnataka"), 
         aes(as.factor(DAY.W), PROP.LISTS, colour = COVID)) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Karnataka",
         x = "Day", y = "Proportion of lists")) /
((ggplot(filter(t_dow_sw, STATE == "Maharashtra"), 
         aes(as.factor(DAY.W), PROP.LISTS, colour = COVID)) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Maharashtra",
         x = "Day", y = "Proportion of lists")) |
ggplot(filter(t_dow_sw, STATE == "Assam"), 
         aes(as.factor(DAY.W), PROP.LISTS, colour = COVID)) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Assam",
         x = "Day", y = "Proportion of lists")) +
plot_layout(guides = "collect") +
plot_annotation(title = "Change in temporal spread of checklists with the pandemic (September to March)",
                subtitle = "Y-axis shows average proportion of checklists from respective days of the week on X-axis") -> t_spread_dow

t_spread_dow

ggsave("03_wrap_figs/13_t_spread_dow.png", 
       plot = t_spread_dow,
       width = 9, height = 9, units = "in")


rm(t_dow_sw, t_dow_nw, t_spread_dow)


```

-   At the national level, birding on Saturdays has decreased, and been balanced by more birding on Wednesdays, while Sunday birding seems to have also increased.\
-   In Kerala, birding seems to have increased during Thursday--Saturday and decreased on Sunday.\
-   In Karnataka there hasn't been much of a change with the pandemic, and there is still a heavy weekend bias in birding activity (Saturday and Sunday levels being similar).\
-   In Gujarat and Maharashtra, Sundays see more birding than Saturdays, but there has been no major impact of the pandemic.\
-   This might mean that the national level patterns might be driven by changes in states with generally low birding activity.

```{r t_spread_2, cache=TRUE, message=FALSE}

##### Change in ToD spread ####

t_tod_sw <- data0_MY_slice_G %>% 
  filter(MONTH %in% month_compar$MONTH) %>% 
  group_by(COVID, STATE, M.YEAR, MONTH) %>% 
  mutate(NO.LISTS = n_distinct(SAMPLING.EVENT.IDENTIFIER)) %>%
  group_by(COVID, STATE, HOUR, M.YEAR, MONTH) %>% 
  dplyr::summarise(NO.LISTS = min(NO.LISTS),
                   TIME.LISTS = replace_na(n_distinct(SAMPLING.EVENT.IDENTIFIER)),
                   PROP.LISTS = TIME.LISTS/NO.LISTS,
                   SE = sqrt((PROP.LISTS)*(1 - PROP.LISTS)/NO.LISTS)) %>% 
  group_by(COVID, STATE, HOUR) %>% 
  dplyr::summarise(PROP.LISTS = mean(PROP.LISTS),
                   SE = sqrt(sum((SE)^2))/n(),
                   CI.L = PROP.LISTS - 1.96*SE,
                   CI.U = PROP.LISTS + 1.96*SE)

t_tod_nw <- t_tod_sw %>%
  group_by(COVID, HOUR) %>% 
  dplyr::summarise(PROP.LISTS = mean(PROP.LISTS),
            SE = sqrt(sum((SE)^2))/n(),
            CI.L = PROP.LISTS - 1.96*SE,
            CI.U = PROP.LISTS + 1.96*SE)


(ggplot(t_tod_nw, 
       aes(as.factor(HOUR), PROP.LISTS, colour = COVID)) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "National level",
         x = "Time of day (hours)", y = "Proportion of lists")) /
((ggplot(filter(t_tod_sw, STATE == "Kerala"), 
         aes(as.factor(HOUR), PROP.LISTS, colour = COVID)) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Kerala",
         x = "Time of day (hours)", y = "Proportion of lists")) |
ggplot(filter(t_tod_sw, STATE == "Karnataka"), 
         aes(as.factor(HOUR), PROP.LISTS, colour = COVID)) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Karnataka",
         x = "Time of day (hours)", y = "Proportion of lists")) /
((ggplot(filter(t_tod_sw, STATE == "Maharashtra"), 
         aes(as.factor(HOUR), PROP.LISTS, colour = COVID)) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Maharashtra",
         x = "Time of day (hours)", y = "Proportion of lists")) |
ggplot(filter(t_tod_sw, STATE == "Assam"), 
         aes(as.factor(HOUR), PROP.LISTS, colour = COVID)) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Assam",
         x = "Time of day (hours)", y = "Proportion of lists")) +
plot_layout(guides = "collect") +
plot_annotation(title = "Change in temporal spread of checklists with the pandemic (September to March)",
                subtitle = "Y-axis shows average proportion of checklists from respective times of the day on X-axis") -> t_spread_tod

t_spread_tod

ggsave("03_wrap_figs/14_t_spread_tod.png", 
       plot = t_spread_tod,
       width = 13, height = 9, units = "in")


rm(t_tod_nw, t_tod_sw, t_spread_tod)


```

-   At the national level, there are two peaks in the day that see highest birding activity: early morning and evening.\
-   In 2020, there was a sharp rise in birding activity at 17:00, and dip at 16:00.\
-   In 2021, birding increased at 06:00 and 15:00, and decreased at 16:00.\
-   The increase in evening birding was prominent in Karnataka, Gujarat and Maharashtra.

### Media

Not "per observer", as this metric from data POV.

```{r media, cache=TRUE, message=FALSE}

temp1 <- data0_MY_slice_G %>% 
  group_by(COVID, M.YEAR, MONTH, STATE) %>% 
  dplyr::summarise(NO.LISTS = n_distinct(SAMPLING.EVENT.IDENTIFIER)) %>%
  ungroup() 

temp2 <- data0_MY_slice_G %>% 
  filter(HAS.MEDIA == 1) %>% 
  group_by(COVID, M.YEAR, MONTH, STATE) %>% 
  dplyr::summarise(NO.MLISTS = n_distinct(SAMPLING.EVENT.IDENTIFIER)) %>%
  ungroup()

media_sw <- temp1 %>% 
  left_join(temp2) %>% 
  mutate(NO.MLISTS = replace_na(NO.MLISTS, 0),
         PROP.MLISTS = NO.MLISTS/NO.LISTS,
         SE = sqrt((PROP.MLISTS)*(1 - PROP.MLISTS)/NO.LISTS),
         CI.L = PROP.MLISTS - 1.96*SE,
         CI.U = PROP.MLISTS + 1.96*SE) 

rm(list = c("temp1","temp2"))

media_nw <- media_sw %>% 
  group_by(COVID, M.YEAR, MONTH) %>% 
  dplyr::summarise(PROP.MLISTS = mean(PROP.MLISTS),
            SE = sqrt(sum((SE)^2))/n(),
            CI.L = PROP.MLISTS - 1.96*SE,
            CI.U = PROP.MLISTS + 1.96*SE) 


(ggplot(media_nw, aes(MONTH, PROP.MLISTS, colour = COVID)) + 
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "National level",
         x = "Month", y = "Proportion of media lists")) /
((ggplot(filter(media_sw, STATE == "Kerala"), 
         aes(MONTH, PROP.MLISTS, colour = COVID)) + 
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Kerala",
         x = "Month", y = "Proportion of media lists")) |
(ggplot(filter(media_sw, STATE == "Karnataka"), 
         aes(MONTH, PROP.MLISTS, colour = COVID)) + 
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Karnataka",
         x = "Month", y = "Proportion of media lists"))) /
((ggplot(filter(media_sw, STATE == "Maharashtra"), 
         aes(MONTH, PROP.MLISTS, colour = COVID)) + 
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Maharashtra",
         x = "Month", y = "Proportion of media lists")) |
(ggplot(filter(media_sw, STATE == "Assam"), 
         aes(MONTH, PROP.MLISTS, colour = COVID)) + 
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Assam",
         x = "Month", y = "Proportion of media lists"))) +
plot_layout(guides= "collect") +
plot_annotation(title = "Change in proportion of media lists with the pandemic",
                subtitle = "Y-axis shows proportion of checklists that contain uploaded media") -> media

media

ggsave("03_wrap_figs/15_media.png", plot = media,
       width = 9, height = 9, units = "in")

rm(list = c("media_nw","media_sw","media"))

```

-   There is no major difference in proportion of media lists before, during and after the pandemic.

### New birders

```{r new, cache=TRUE, message=FALSE}

load("data/new_obsr_data.RData")

# not new to the state, but new overall, just grouped by state of first eBirding
new_obsr_sw <- new_obsr_data %>% 
  group_by(COVID, LE.YEAR, LE.MONTH, STATE) %>% 
  dplyr::summarise(NEW = n_distinct(OBSERVER.ID)) %>% 
  ungroup()

set.seed(765)
new_obsr_nw <- new_obsr_sw %>% 
  group_by(COVID, LE.YEAR, LE.MONTH) %>% 
  dplyr::summarise(NEW = boot_conf(x = NEW)) %>% 
  group_by(COVID, LE.YEAR, LE.MONTH) %>% 
  dplyr::summarise(SE = sd(NEW),
                   NEW = mean(NEW),
                   CI.L = NEW - 1.96*SE,
                   CI.U = NEW + 1.96*SE)


(ggplot(new_obsr_nw, aes(LE.MONTH, NEW, colour = COVID)) + 
    scale_y_log10() +
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = CI.L, ymax = CI.U), 
                  size = 1.25, width = 0.4, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "National level",
         x = "Month", y = "New eBirders")) /
((ggplot(filter(new_obsr_sw, STATE == "Kerala"), 
         aes(LE.MONTH, NEW, colour = COVID)) + 
    scale_y_log10() +
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Kerala",
         x = "Month", y = "New eBirders")) |
(ggplot(filter(new_obsr_sw, STATE == "Karnataka"), 
         aes(LE.MONTH, NEW, colour = COVID)) + 
    scale_y_log10() +
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Karnataka",
         x = "Month", y = "New eBirders"))) /
((ggplot(filter(new_obsr_sw, STATE == "Maharashtra"), 
         aes(LE.MONTH, NEW, colour = COVID)) + 
    scale_y_log10() +
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Maharashtra",
         x = "Month", y = "New eBirders")) |
(ggplot(filter(new_obsr_sw, STATE == "Assam"), 
         aes(LE.MONTH, NEW, colour = COVID)) + 
    scale_y_log10() +
    scale_x_continuous(breaks = 1:12) + 
    geom_point(size = 3, position = position_dodge(0.5)) +
    scale_colour_manual(values = covid_palette) +
    labs(title = "Assam",
         x = "Month", y = "New eBirders"))) +
plot_layout(guides = "collect") +
plot_annotation(title = "Change in eBirder growth with the pandemic",
                subtitle = "Y-axis shows average number of new eBirders") -> new

new # plot

ggsave("03_wrap_figs/16_new.png", plot = new,
       width = 9, height = 9, units = "in")


rm(list = c("new_obsr_nw","new_obsr_sw","new"))

```

-   At the national level, the pandemic has seen a greater number of monthly new eBirders than before, presumably due to greater frequency and impact of outreach initiatives.\
-   While Kerala and Karnataka both have seen increases in monthly new eBirders with the pandemic, the increase is more striking in Karnataka than in Kerala.
